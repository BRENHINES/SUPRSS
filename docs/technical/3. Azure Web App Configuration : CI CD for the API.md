# SUPRSS – Azure Web App for Containers: guide de configuration & déploiement

## 0) Portée & architecture

Ce document décrit la configuration et le déploiement de l’API FastAPI de SUPRSS sur Azure App Service en utilisant des conteneurs Docker. 
Il couvre les étapes de création d’un registre de conteneurs, la configuration de l’application Web, la gestion des variables d’environnement, 
ainsi que les bonnes pratiques de sécurité et de supervision.

* **Cible**: Azure App Service **Web App for Containers (Linux)** exposant l’API FastAPI dans un **conteneur** (Uvicorn → port 8000).
* **Registry**: Azure Container Registry (**ACR**) ou registre externe (GHCR / Docker Hub).
* **Données**: PostgreSQL Flexible Server (existant), éventuellement Redis.
* **Réseau**: accès public par défaut, options VNet/Access Restrictions.

---

## 1) Prérequis

Avant de commencer, assurez-vous de disposer des éléments suivants:

* Abonnement Azure + **Resource Group** (vous pouvez **réutiliser** celui du projet de base ou en créer un nouveau).
* **Azure CLI** ≥ 2.55 (`az version`).
* Rôle **Contributor** sur le RG et **AcrPush/AcrPull** sur ACR.
* Docker local pour build/push l’image.

**Nommage recommandé**

```
RG           = suprss-rg
LOCATION     = westeurope
ACR_NAME     = suprssacr
PLAN_NAME    = suprss-plan
WEBAPP_NAME  = suprss-api
IMAGE_NAME   = suprss/backend
TAG          = v1
```

---

## 2) Dockerfile minimal (rappel)

Voici un exemple de Dockerfile pour l’API FastAPI. Il utilise Python 3.12 et Uvicorn pour servir l’application.
Mais vous disposer du fichier entier original dans le dossier backend du projet.
```dockerfile
FROM python:3.12-slim
WORKDIR /app
COPY pyproject.toml poetry.lock* requirements*.txt* /app/

# au choix: pip ou poetry
RUN pip install --no-cache-dir -r requirements.txt
COPY backend /app/backend
EXPOSE 8000
ENV PYTHONUNBUFFERED=1
CMD ["uvicorn", "backend.app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

---

## 3) Création & configuration d’un ACR (option recommandé)

Si vous utilisez un registre externe (GHCR/Docker Hub) le cas que nous avons choisi, passez directement à la section 4.
Mais pour la création et la configuration d’un registre Azure Container Registry (ACR), suivez ces étapes:

```bash
az acr create \
  -g $RG -n $ACR_NAME --sku Basic --location $LOCATION

# login Docker (permet de pousser l’image)
az acr login -n $ACR_NAME

ACR_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)
# Build + tag + push
docker build -t $ACR_SERVER/$IMAGE_NAME:$TAG .
docker push $ACR_SERVER/$IMAGE_NAME:$TAG
```

> Si vous utilisez un registre externe (GHCR/Docker Hub), poussez-y l’image et notez `REGISTRY_SERVER`, `IMAGE`, `TAG`.

---

## 4) Plan App Service & Web App (Linux, conteneur)

Pour héberger notre API FastAPI dans un conteneur, nous allons créer un plan App Service et une Web App. 
Vous pouvez le faire via le portail Azure ou en ligne de commande avec Azure CLI.

Pour créer un plan App Service et une Web App pour conteneurs, utilisez les commandes suivantes.

```bash
# Plan Linux (B1 suffisant en dev)
az appservice plan create -g $RG -n $PLAN_NAME --is-linux --sku B1

# Web App (sans image au départ)
az webapp create -g $RG -p $PLAN_NAME -n $WEBAPP_NAME --runtime "PYTHON|3.12" --deployment-container-image-name nginx
```

> On définira l’image réelle au §5. Le runtime ici est ignoré quand on passe en conteneur.

---

## 5) Brancher l’image de conteneur

### 5.1 Depuis ACR (avec **Managed Identity**)

La création de ACR et la Web App permet de configurer l’identité managée pour l’accès au registre. Et la configuration de la Web App pour utiliser l’image du registre ACR.
Donc nous devons connecter la Web App à l’image de conteneur dans ACR afin de rendre le CI/CD opérationnel et continue. Et pour se faire nous devons, utiliser les commande suivantes:

```bash
# Activer l’identité managée de la Web App
az webapp identity assign -g $RG -n $WEBAPP_NAME
PRINCIPAL_ID=$(az webapp identity show -g $RG -n $WEBAPP_NAME --query principalId -o tsv)
SCOPE=$(az acr show -n $ACR_NAME --query id -o tsv)
az role assignment create --assignee $PRINCIPAL_ID --role "AcrPull" --scope $SCOPE

# Pointez la Web App sur l’image ACR
az webapp config container set -g $RG -n $WEBAPP_NAME \
  --docker-custom-image-name $ACR_SERVER/$IMAGE_NAME:$TAG \
  --docker-registry-server-url https://$ACR_SERVER
```

### 5.2 Depuis registre privé externe

Si vous utilisez un registre externe (par exemple, GitHub Container Registry), vous devez fournir les informations d’identification du registre.
Assurez-vous d’avoir un **Personal Access Token** (PAT) avec les permissions nécessaires pour accéder à l’image.
Vous pouvez le faire en utilisant la commande suivante:

```bash
az webapp config container set -g $RG -n $WEBAPP_NAME \
  --docker-custom-image-name ghcr.io/owner/$IMAGE_NAME:$TAG \
  --docker-registry-server-url https://ghcr.io \
  --docker-registry-server-user <USERNAME> \
  --docker-registry-server-password <TOKEN>
```

---

## 6) Paramètres d’application (env vars)

Pour que l’API fonctionne correctement, nous devons configurer les variables d’environnement nécessaires. pour cela, nous allons utiliser les paramètres d’application de la Web App.
Vous pouvez le faire via le portail Azure ou en ligne de commande avec Azure CLI. Dans le cadre de notre projet, 
nous avons utiliser essentiellement le portail Azure pour la configuration des paramètres d’application,
et ainsi nous avons intégrer l'ensemble de nos variables d’environnement nécessaires pour le bon fonctionnement de l’API FastAPI.

Pour se faire nous devons nous rendre dans la section **Configuration** de la Web App et ajouter les variables d’environnement nécessaires.
Dans **Web App ➜ Configuration ➜ Paramètres d’application**:

### 6.1 Conteneur

Pour avoir accès à l’API via le port 8000, nous devons définir la variable d’environnement `WEBSITES_PORT` à 8000.

```
WEBSITES_PORT = 8000   # indispensable si Uvicorn écoute 8000
```

### 6.2 Sécurité JWT

Pour assurer la sécurité de l’API, nous devons configurer les clés secrètes pour JWT et Refresh Token.
Ces clés doivent être suffisamment longues et complexes pour garantir la sécurité des tokens JWT.
Vous pouvez les générer avec un outil comme `openssl` ou `python -c "import secrets; print(secrets.token_urlsafe(32))"`.
```
JWT_SECRET_KEY=<Votre clé secrète JWT ici>
REFRESH_SECRET_KEY=<Votre clé secrète Refresh Token ici>
JWT_ALGORITHM=HS256 # algorithme de signature
ACCESS_TOKEN_EXPIRE_MINUTES=30 # durée de validité du token d’accès
REFRESH_TOKEN_EXPIRE_DAYS=7 # durée de validité du refresh token
```

### 6.3 Base de données (PostgreSQL Flexible Server)

Pour connecter l’API à la base de données PostgreSQL configurer plus tôt dans le fichier de 
[Configuration de Database Azure](1.%20Database%20Azure%20Configuration.md), 
nous devons configurer les variables d’environnement suivantes :

```
POSTGRES_HOST=<Votre hôte PostgreSQL ici>
POSTGRES_DB=<Votre nom de base de données ici>
POSTGRES_USER=<Votre utilisateur PostgreSQL ici>
POSTGRES_PASS=********
POSTGRES_PORT=5432
```

### 6.4 CORS & autres

Pour permettre à l’API d’être accessible depuis le front-end, nous devons configurer les CORS (Cross-Origin Resource Sharing).
Vous pouvez définir les origines autorisées dans la variable `CORS_ORIGINS`.
Vous pouvez également configurer d’autres paramètres généraux de l’application, comme le nom et la version de l’application, 
le mode de débogage, et l’environnement (production ou développement).

```
CORS_ORIGINS=http://localhost:3000,https://app.suprss.com
APP_NAME=<Votre nom d’application ici>
APP_VERSION=<Votre version d’application ici>
DEBUG=False
ENV=production
```

### 6.5 Avatars (Azure Blob) – si utilisés

Pour la gestion des utilisateurs, ceux ci utilisent des avatars qui seront stockés dans Azure Blob Storage.
Pour configurer le stockage des avatars, vous devez créer un compte de stockage Azure et un conteneur pour les avatars.
Ensuite, configurez les variables d’environnement suivantes dans la Web App:

```
AZURE_STORAGE_ACCOUNT=xxxx
AZURE_STORAGE_CONTAINER=avatars
AVATAR_BASE_URL=https://xxxx.blob.core.windows.net/avatars
AZURE_SAS_TTL_MIN=10
AZURE_AVATAR_MAX_MB=2
AZURE_AVATAR_ALLOWED_TYPES=["image/png","image/jpeg","image/webp"]
```

> **Astuce**: pour des secrets sensibles, utilisez **Key Vault references** avec **Managed Identity**:

```
POSTGRES_PASS=@Microsoft.KeyVault(SecretUri=https://<kv>.vault.azure.net/secrets/POSTGRES_PASS/<version>)
```

Enregistrez puis **Redémarrez** la Web App.

---

## 7) Paramètres généraux utiles

Voici quelques paramètres généraux recommandés pour la Web App afin d’assurer un bon fonctionnement de l’API FastAPI:

* **Always On**: **Activé** (recommandé, nécessite B1+).
* **HTTP version**: HTTP/2 activé (par défaut).
* **ARR affinity**: désactivable si API stateless.
* **Health check**: Path = `/health` (Web App ➜ Paramètres généraux ➜ Health check).
* **Authentification de base SCM**: activez-la uniquement si besoin de Kudu/publish profile.

---

## 8) Vérifier le démarrage & les logs

Après avoir configuré la Web App et les variables d’environnement, il est important de vérifier que l’API démarre correctement et de surveiller les logs pour détecter d’éventuels problèmes.
Vous pouvez le faire via le portail Azure ou en ligne de commande avec Azure CLI.

### 8.1 Flux de logs

Pour vérifier les logs de l’application et du conteneur, vous pouvez utiliser les options suivantes:

* **Web App ➜ Log stream** (portail): affiche les logs du conteneur.
* **CLI**:

```bash
az webapp log tail -g $RG -n $WEBAPP_NAME
```

### 8.2 Symptômes fréquents & correctifs

Voici quelques symptômes fréquents que vous pourriez rencontrer lors de la configuration de l’API FastAPI sur Azure App Service, ainsi que les causes probables et les correctifs associés:

| Symptôme                          | Cause probable                        | Correctif                                                                |
|-----------------------------------|---------------------------------------|--------------------------------------------------------------------------|
| 502 Bad Gateway                   | Conteneur non démarré                 | Vérifier logs, `WEBSITES_PORT`, commande de démarrage                    |
| Image pull failed                 | Pas de droit ACR                      | Vérifier AcrPull (Managed Identity) ou credentials du registre           |
| Env vars non lues                 | Mauvais nom/typo                      | Vérifier **Configuration**, redémarrer, check dans logs votre `settings` |
| "/" redirige vers 404             | API FastAPI OK mais route inexistante | Tester `/health`, `/docs`                                                |
| Message *SCM basic auth disabled* | Kudu désactivé                        | Activer **Authentification de base SCM** (si nécessaire)                 |

---

## 9) Déploiements

Pour déployer l’API FastAPI sur Azure App Service, vous pouvez utiliser différentes méthodes.
La méthode la plus courante est d’utiliser un pipeline CI/CD pour automatiser le processus de déploiement.
Vous pouvez utiliser des outils comme GitHub Actions, Azure DevOps, ou d’autres outils CI/CD pour automatiser le processus de build et de déploiement de l’image de conteneur.
Dans le cadre de notre projet, nous avons choisi d’utiliser GitHub Actions pour automatiser le déploiement de l’API FastAPI sur Azure App Service.
Voici deux méthodes pour déployer l’API FastAPI sur Azure App Service:

### 9.1 Manuel par tag d’image

Pour déployer manuellement l’API FastAPI sur Azure App Service, vous pouvez suivre les étapes suivantes:

1. Pusher l’image `:$NEW_TAG` dans le registre.
2. Mettre à jour l’image de la Web App:

```bash
az webapp config container set -g $RG -n $WEBAPP_NAME \
  --docker-custom-image-name $ACR_SERVER/$IMAGE_NAME:$NEW_TAG \
  --docker-registry-server-url https://$ACR_SERVER
az webapp restart -g $RG -n $WEBAPP_NAME
```

### 9.2 GitHub Actions (schéma)

Pour automatiser le déploiement de l’API FastAPI sur Azure App Service, vous pouvez utiliser GitHub Actions.
Voici un exemple de workflow GitHub Actions pour déployer l’API FastAPI sur Azure App Service:

* Secrets: `AZURE_CREDENTIALS` (OIDC ou SP), `AZURE_CONTAINER_REGISTRY`, `ACR_LOGIN_SERVER`, `ACR_NAME`…
* Pipeline: build → push ACR → `az webapp config container set` → restart.

```yaml
name: ci-cd
on: [push]
jobs:
  build-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Azure ACR login
        run: az acr login -n ${{ secrets.ACR_NAME }}
      - name: Build & push
        run: |
          ACR_SERVER=$(az acr show -n ${{ secrets.ACR_NAME }} --query loginServer -o tsv)
          docker build -t $ACR_SERVER/${{ vars.IMAGE_NAME }}:${{ github.sha }} .
          docker push $ACR_SERVER/${{ vars.IMAGE_NAME }}:${{ github.sha }}
      - name: Update Web App image
        run: |
          ACR_SERVER=$(az acr show -n ${{ secrets.ACR_NAME }} --query loginServer -o tsv)
          az webapp config container set \
            -g ${{ vars.RG }} -n ${{ vars.WEBAPP_NAME }} \
            --docker-custom-image-name $ACR_SERVER/${{ vars.IMAGE_NAME }}:${{ github.sha }} \
            --docker-registry-server-url https://$ACR_SERVER
          az webapp restart -g ${{ vars.RG }} -n ${{ vars.WEBAPP_NAME }}
```

> Variante: utiliser **deploy slots** (staging → production) et `az webapp deployment slot swap`.

---

## 10) Réseau & sécurité

Pour sécuriser l’accès à l’API FastAPI déployée sur Azure App Service, 
il est important de configurer correctement le réseau et la sécurité. Voici quelques recommandations:

* **HTTPS Only**: activé.
* **Access Restrictions**: restreindre par IP si nécessaire.
* **VNet Integration** (sortant): utile pour joindre des ressources privées (DB private endpoint).
* **Key Vault**: stocker les secrets et les référencer (cf. §6.5).
* **Managed Identity**: préférer pour ACR, Key Vault, Storage.

---

## 11) Stockage des avatars (rappel rapide)

Pour gérer les avatars des utilisateurs, nous allons utiliser Azure Blob Storage. Voici les étapes à suivre:

* **Storage Account** + conteneur `avatars` privé.
* Génération **SAS** courte durée côté backend ou upload proxy via SDK.
* Variables: `AZURE_STORAGE_ACCOUNT`, `AZURE_STORAGE_CONTAINER`, `AVATAR_BASE_URL`, etc.
* Nettoyage: DELETE avatar supprime le blob.

---

## 12) Supervision & diagnostics

Pour assurer le bon fonctionnement de l’API FastAPI déployée sur Azure App Service, 
il est important de configurer la supervision et les diagnostics. Voici les éléments à configurer:

* **Log stream** + **Container logs** (activer *Docker logs* si désactivés).
* **Application Insights** (optionnel): exporter les logs applicatifs si vous instrumentez.
* **Metrics**: CPU/Mémoire, erreurs HTTP, temps de réponse.

---

## 13) Check-list de validation

Voici une check-list de validation pour s’assurer que l’API FastAPI est correctement déployée et configurée sur Azure App Service:

* [ ] Web App **Running** et **/health** → 200.
* [ ] **WEBSITES\_PORT=8000** présent.
* [ ] Variables d’env **JWT/DB** définies (aucune erreur Pydantic Settings).
* [ ] Image pointe sur le bon **tag**.
* [ ] **Always On** activé.
* [ ] Health check configuré (/health).
* [ ] CORS conforme au front.
* [ ] Accès Postgres OK (firewall/SSL).

---

## 14) Dépannage avancé

En cas de problèmes lors du déploiement ou de l’exécution de l’API FastAPI sur Azure App Service, voici quelques pistes de dépannage:

* **Crashloop**: vérifier la commande de démarrage (CMD/ENTRYPOINT) et la présence des migrations DB.
* **Port 80 attendu**: App Service ping sur 80 si `WEBSITES_PORT` absent.
* **Kudu/SCM désactivé**: activer *Authentification de base SCM* si besoin d’accès `*.scm.azurewebsites.net`.
* **Perf**: activer *Always On*, choisir un plan supérieur, ouvrir un slot *staging*.

---

## 15) Évolutions possibles

Pour améliorer la configuration et le déploiement de l’API FastAPI sur Azure App Service, voici quelques évolutions possibles:

* **Slots** (staging/prod) + swap contrôlé.
* **Scale out** (instances) + sticky sessions off (API stateless).
* **Key Vault** pour tous les secrets.
* **Private Endpoint** pour DB/Storage.
