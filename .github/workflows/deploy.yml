name: Deploy-Backend

on:
  push:
    branches: [ master ]
  workflow_dispatch: {}

env:
  IMAGE_NAME: suprss-api

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) Login Azure (via Service Principal OIDC ou secret JSON)
      - name: Azure Login
        uses: azure/login@v2
        with:
          # Option A (recommandé) : Federated Credentials (OIDC)
          # client-id: ${{ secrets.AZURE_CLIENT_ID }}
          # tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          # subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

          # Option B : JSON Service Principal (facile à mettre en place)
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # 2) Login ACR
      - name: Azure Container Registry Login
        run: |
          az acr login --name ${{ secrets.ACR_NAME }}
      # ACR_LOGIN_SERVER ex: myregistry.azurecr.io
      - name: Set image tag
        id: settag
        run: echo "TAG=${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT

      # 3) Build & push
      - name: Build image
        run: |
          docker build -t ${{ steps.settag.outputs.TAG }} -f backend/Dockerfile backend
          docker push ${{ steps.settag.outputs.TAG }}

      # 4) Déploiement Web App for Containers
      - name: Deploy to Web App
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ secrets.AZURE_WEBAPP_NAME }}
          images: ${{ steps.settag.outputs.TAG }}

      # 5) (Optionnel) Exécuter alembic upgrade (si tu ne le fais pas au démarrage)
      # Pour Web App Linux, le plus simple est de le mettre dans l'ENTRYPOINT/command du conteneur.
